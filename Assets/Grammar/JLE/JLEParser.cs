//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from JLE.g4 by ANTLR 4.5.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
[System.CLSCompliant(false)]
public partial class JLEParser : Parser {
	public const int
		ARGS=1, ARG=2, DIR=3, ANG=4, INT=5, IDENTIFIER=6, LEFTPAR=7, RIGHTPAR=8, 
		SEMICOLON=9, COMMA=10, NEWLINE=11, WS=12;
	public const int
		RULE_prog = 0, RULE_cmd = 1, RULE_func = 2;
	public static readonly string[] ruleNames = {
		"prog", "cmd", "func"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, "'('", "')'", "';'", "','"
	};
	private static readonly string[] _SymbolicNames = {
		null, "ARGS", "ARG", "DIR", "ANG", "INT", "IDENTIFIER", "LEFTPAR", "RIGHTPAR", 
		"SEMICOLON", "COMMA", "NEWLINE", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "JLE.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


		public Compiler compiler = new Compiler();

	public JLEParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class ProgContext : ParserRuleContext {
		public CmdContext[] cmd() {
			return GetRuleContexts<CmdContext>();
		}
		public CmdContext cmd(int i) {
			return GetRuleContext<CmdContext>(i);
		}
		public ProgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prog; } }
		public override void EnterRule(IParseTreeListener listener) {
			IJLEListener typedListener = listener as IJLEListener;
			if (typedListener != null) typedListener.EnterProg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IJLEListener typedListener = listener as IJLEListener;
			if (typedListener != null) typedListener.ExitProg(this);
		}
	}

	[RuleVersion(0)]
	public ProgContext prog() {
		ProgContext _localctx = new ProgContext(Context, State);
		EnterRule(_localctx, 0, RULE_prog);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 7;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 6; cmd();
				}
				}
				State = 9;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==IDENTIFIER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CmdContext : ParserRuleContext {
		public FuncContext func() {
			return GetRuleContext<FuncContext>(0);
		}
		public ITerminalNode SEMICOLON() { return GetToken(JLEParser.SEMICOLON, 0); }
		public ITerminalNode NEWLINE() { return GetToken(JLEParser.NEWLINE, 0); }
		public CmdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cmd; } }
		public override void EnterRule(IParseTreeListener listener) {
			IJLEListener typedListener = listener as IJLEListener;
			if (typedListener != null) typedListener.EnterCmd(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IJLEListener typedListener = listener as IJLEListener;
			if (typedListener != null) typedListener.ExitCmd(this);
		}
	}

	[RuleVersion(0)]
	public CmdContext cmd() {
		CmdContext _localctx = new CmdContext(Context, State);
		EnterRule(_localctx, 2, RULE_cmd);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 11; func();
			State = 12; Match(SEMICOLON);
			State = 13; Match(NEWLINE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncContext : ParserRuleContext {
		public IToken _IDENTIFIER;
		public IToken _ARGS;
		public ITerminalNode IDENTIFIER() { return GetToken(JLEParser.IDENTIFIER, 0); }
		public ITerminalNode LEFTPAR() { return GetToken(JLEParser.LEFTPAR, 0); }
		public ITerminalNode ARGS() { return GetToken(JLEParser.ARGS, 0); }
		public ITerminalNode RIGHTPAR() { return GetToken(JLEParser.RIGHTPAR, 0); }
		public FuncContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_func; } }
		public override void EnterRule(IParseTreeListener listener) {
			IJLEListener typedListener = listener as IJLEListener;
			if (typedListener != null) typedListener.EnterFunc(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IJLEListener typedListener = listener as IJLEListener;
			if (typedListener != null) typedListener.ExitFunc(this);
		}
	}

	[RuleVersion(0)]
	public FuncContext func() {
		FuncContext _localctx = new FuncContext(Context, State);
		EnterRule(_localctx, 4, RULE_func);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 15; _localctx._IDENTIFIER = Match(IDENTIFIER);
			State = 16; Match(LEFTPAR);
			State = 17; _localctx._ARGS = Match(ARGS);
			State = 18; Match(RIGHTPAR);
			 compiler.addGenericCommand((_localctx._IDENTIFIER!=null?_localctx._IDENTIFIER.Text:null), (_localctx._ARGS!=null?_localctx._ARGS.Text:null)); 
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\xE");
		sb.Append("\x18\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x3\x2\x6\x2\n\n\x2\r\x2");
		sb.Append("\xE\x2\v\x3\x3\x3\x3\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3");
		sb.Append("\x4\x3\x4\x3\x4\x2\x2\x5\x2\x4\x6\x2\x2\x15\x2\t\x3\x2\x2\x2");
		sb.Append("\x4\r\x3\x2\x2\x2\x6\x11\x3\x2\x2\x2\b\n\x5\x4\x3\x2\t\b\x3");
		sb.Append("\x2\x2\x2\n\v\x3\x2\x2\x2\v\t\x3\x2\x2\x2\v\f\x3\x2\x2\x2\f");
		sb.Append("\x3\x3\x2\x2\x2\r\xE\x5\x6\x4\x2\xE\xF\a\v\x2\x2\xF\x10\a\r");
		sb.Append("\x2\x2\x10\x5\x3\x2\x2\x2\x11\x12\a\b\x2\x2\x12\x13\a\t\x2\x2");
		sb.Append("\x13\x14\a\x3\x2\x2\x14\x15\a\n\x2\x2\x15\x16\b\x4\x1\x2\x16");
		sb.Append("\a\x3\x2\x2\x2\x3\v");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
